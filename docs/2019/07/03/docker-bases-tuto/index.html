<!DOCTYPE html><html lang="en"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Docker, les bases | btor.fr</title><meta name="description" content="Passionné d'informatique, de développement web & applicatif depuis plus de 10 ans. Je partage mon quotidien de tech ! "><meta itemprop="name" content="Thibaut BAYER"><meta itemprop="description" content="Passionné d'informatique, de développement web & applicatif depuis plus de 10 ans. Je partage mon quotidien de tech ! "><meta itemprop="image" content="https://btor.fr/assets/images/docker-bases/main.png"><meta property="og:url" content="https://btor.fr/2019/07/03/docker-bases-tuto/"><meta property="og:type" content="website"><meta property="og:title" content="Docker, les bases | btor.fr"><meta property="og:site_name" content="btor.fr"><meta property="og:description" content="Passionné d'informatique, de développement web & applicatif depuis plus de 10 ans. Je partage mon quotidien de tech ! "><meta property="og:image" content="https://btor.fr/assets/images/docker-bases/main.png"><meta name="twitter:url" content="https://btor.fr/2019/07/03/docker-bases-tuto/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Docker, les bases | btor.fr"><meta name="twitter:site" content="btor.fr"><meta name="twitter:description" content="Passionné d'informatique, de développement web & applicatif depuis plus de 10 ans. Je partage mon quotidien de tech ! "><meta name="twitter:creator" content="@biiitor"><meta property="twitter:image" content="https://btor.fr/assets/images/docker-bases/main.png"><link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico"><link rel="stylesheet" href="/assets/css/app.min.css"><link rel="alternate" type="application/rss+xml" title="btor.fr" href="/feed.xml"><link rel="canonical" href="/2019/07/03/docker-bases-tuto/"></head><body id="docker-les-bases" class="post-layout"><header class="header"> <a class="header__title" href="https://btor.fr/"><img width="75" src="/assets/images/logo/logo.dark.small.png"/></a><nav><ul class="header__list"><li><a href="/qui-suis-je">❓ Qui suis-je</a></li><li><a href="/help">❤️ Me soutenir</a></li></ul></nav></header><main class="💈"><div class="post"><article itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting"><div class="post__header section-padding--double"><div class="grid-small"><h2 itemprop="name headline">Docker, les bases</h2><time class="post__date" datetime="2019-07-03T00:00:00-05:00" itemprop="datePublished">03/07/2019</time></div></div><div class="post__img"><div><figure class="absolute-bg" style="background-image: url('/assets/images/docker-bases/main.png');"></figure></div></div><div class="post__content section-padding"><div class="grid"><div id="markdown" itemprop="articleBody"><p>Régulièrement je me rends compte que certains développeurs ne sont pas à l’aise avec Docker. C’était aussi mon cas au début, Docker peut paraître complexe et flou au premier abord puis rapidement il devient <strong>indispensable</strong>, mais pourquoi ?</p><p>Dans cet article, je tâcherai de revenir sur les principaux concepts en essayant de faire le plus simple possible. Si vous avez déjà un niveau avancé avec Docker, cet article n’est pas fait pour vous.</p><h1 id="-cest-quoi-docker-">❓ C’est quoi Docker ?</h1><blockquote><p>Docker est un logiciel libre permettant facilement de lancer des applications dans des conteneurs logiciels.</p></blockquote><p><em>Source wikipédia</em></p><p>Cool, mais du coup, qu’est ce qu’un conteneur ? Avant d’expliquer le concept de conteneurisation, commençons par comprendre la base: <strong>la virtualisation</strong>.</p><h3 id="-virtualisation-vs-conteneurisation">🐳 Virtualisation VS Conteneurisation</h3><p>Ça devrait parler à beaucoup d’entre vous, c’est le fait <strong>d’émuler</strong> un système d’exploitation dans un autre, par exemple, au sein d’un système d’exploitation Windows 10, j’émule un Linux, un MacOS ou même un Windows 3.1. Le logiciel permettant d’émuler nos systèmes d’exploitation est appelé un <strong>Hyperviseur</strong>.</p><p>Il existe deux types d’hyperviseur:</p><ul><li><strong>L’hyperviseur de type 2</strong>:</li></ul><p><img src="/assets/images/docker-bases/hyperviseur_type_2.png" alt="" /> <em>Source wikipédia</em></p><p>Vous les connaissez certainement sans savoir qu’ils sont de type 2: VirtualBox et VMWare workstation. Le type 2 veut dire que l’hyperviseur a besoin d’un système d’exploitation “hôte” (maitre) pour fonctionner. Par exemple, vous ne pouvez pas lancer Virtualbox seul sans Windows ou Ubuntu.</p><ul><li><strong>L’hyperviseur de type 1</strong>:</li></ul><p><img src="/assets/images/docker-bases/hyperviseur_type_1.png" alt="" /> <em>Source wikipédia</em></p><p>A la différence du type 2, le type 1 fonctionne directement comme un “système hôte” et se charge de communiquer directement avec le matériel. L’avantage du type 1 est qu’il permet d’avoir de meilleur performance étant donné qu’on dispose d’une couche applicative en moins contrairement au type 2 où le système d’exploitation hôte, sera consommateur de ressources. Hyper-V (Microsoft) est un hyperviseur de type 1.</p><p>Et la conteneurisation dans tout ça ?</p><p>Un conteneur, c’est grossièrement la même chose qu’une machine virtuelle, notre conteneur va avoir son propre système <strong>SAUF</strong> que celui-ci communiquera directement avec le système d’exploitation hôte et pas nécessairement avec un hyperviseur. L’intérêt ? Un gain de performance pardi !</p><h3 id="️-platformes-win-linux-mac">🖥️ Platformes (win, linux, mac)</h3><p>Maintenant que l’on sait ce qu’est un hyperviseur, qu’on comprend la différence entre un conteneur et une machine virtuelle, est-ce qu’il y a une différence entre les différentes plateformes ?</p><p><img src="https://media.giphy.com/media/S3Ot3hZ5bcy8o/giphy.gif" alt="" /></p><p>Oh que oui !</p><p>Docker ne se comporte pas réellement de la même façon en fonction des environnements. Docker se base sur les conteneurs LXC linux et propose une API plus accessible.</p><p>Vous voyez le problème ?</p><p>Qui dit Linux, dit : On va avoir un problème avec Windows et Mac. Effectivement, si vous utilisez Linux sur votre machine hôte vous n’aurez aucun problème, Docker est supporté nativement, par contre sous Windows et Mac vous aurez une couche supplémentaire pour faire fonctionner Docker… <strong>Une machine virtuelle !</strong></p><p><img src="https://media.giphy.com/media/LyJ6KPlrFdKnK/giphy.gif" alt="" /></p><p>Comme je vous l’ai dit, Docker a besoin de Linux (LXC) pour fonctionner et quand vous n’êtes pas sous Linux, votre version de Docker (<code class="highlighter-rouge">DockerForMac</code> ou <code class="highlighter-rouge">DockerForWindows</code>) utilisera une machine virtuelle pour exécuter Docker. C’est pour cela que vous remarquerez assez rapidement que vos applications conteneurisées sont plus lentes sur Windows et Mac (les temps de latences dépendent de votre utilisation/application, des inputs/outputs nécessaires etc) Rassurez-vous, c’est totalement transparent pour vous ! DockerForMac (ou DockerForWindows) s’occupera lui même de gérer la machine virtuelle, vous n’avez pas d’hyperviseur à installer. A noter aussi que Docker n’est pas réservé à la conteneurisation d’image Linux, sous Windows vous aurez le choix entre des conteneurs Windows ou Linux mais vous ne pouvez pas exécuter les deux en même temps, tout comme vous ne pourrez pas exécuter un conteneur Windows sous Linux.</p><p><strong>Debriefing</strong></p><ul><li>Docker est plus lent sous MacOs et Windows</li><li>Les conteneurs partagent le noyau hôte (virtualisé ou non)</li><li>On peut lancer des conteneurs de différents systèmes d’exploitation tant que la système d’exploitation qui gère les conteneurs est le même que ceux-ci. Exemple : Un ordinateur sous windows 10 qui lance une machine virtuelle Ubuntu et qui dans celle ci aura des conteneurs sous debian.</li></ul><h1 id="️-dockerfile-instructions-et-registry">🗒️ Dockerfile, instructions et Registry</h1><blockquote><p>Si vous désirez continuer à lire cet article tout en lançant les commandes, vous devez bien évidemment avoir Docker d’installé et de fonctionnel)</p></blockquote><p>Maintenant que nous avons vu le principe même de Docker et de la conteneurisation, passons à la pratique. Comme nous l’avons vu, l’objectif de Docker est de simplifier la création et la manipulation de conteneurs. Pour se faire, Docker met à disposition une API simple qui attend des <strong>instructions</strong> pour fonctionner. Ces instructions sont déclarés au sein d’un fichier nommé <strong>Dockerfile</strong>.</p><p>Ce même fichier est utilisé pour construire (build) l’image, l’image construite sera ensuite envoyée vers un “serveur Docker” qu’on appelle <strong>Registry</strong>. Le <strong>Docker Hub</strong> est un <strong>Registry</strong> gratuit mis à disposition de tout le monde (des plans payant existent aussi) mais il existe aussi d’autres Registry payant (plus performant, possibilité de gérer plusieurs repository privés etc). Vous pouvez aussi gérer vous même votre propre registry. Pour simplifier, Docker Hub est un peu le <strong>Github</strong> de git, vous avez le droit à un repository privé et à autant de repository public que vous le désirez et si vous désirez avoir plus de repository privé, bah vous payez … :)</p><p>Les images sont stockées avec des <code class="highlighter-rouge">Tag</code>, ces tags permettent de versionner les images sur le repository, par exemple si on regarde <a href="https://hub.docker.com/_/debian">les images disponibles pour Debian</a> On s’aperçoit qu’il existe des images pour plusieurs versions de Debian (Jessie, Buster, Stretch etc..) qui sont en stable mais aussi des versions expérimentales, testing, Release candidate etc.</p><h3 id="️-lancer-son-premier-conteneur">⚙️ Lancer son premier conteneur</h3><p>Récupérons une image de Debian et regardons ce qu’il se passe :</p><ul><li>Taper <code class="highlighter-rouge">docker run -it debian:jessie sh</code></li><li>Vous devriez normalement tomber sur un shell avec juste <code class="highlighter-rouge">#</code> d’afficher.</li><li>Taper <code class="highlighter-rouge">cat /etc/debian_version</code></li><li>Vous devriez voir <code class="highlighter-rouge">8.11</code> s’afficher</li><li>Nous sommes bien sur une version 8 de Debian, good !</li></ul><p>Sans presque rien faire, vous avez exécuter votre premier conteneur et vous avez exécuté une commande dans celui-ci ! Congrats ! Revenons maintenant sur ce que nous avons tapé:</p><ul><li><code class="highlighter-rouge">docker run</code> : Permet de récupérer une image du Registry et de l’exécuter, si vous désirez uniquement récupérer une image docker sans même l’exécuter, vous pouvez utiliser la commande <code class="highlighter-rouge">docker pull</code>.</li><li><code class="highlighter-rouge">-it</code> : Permet de lancer le conteneur en mode interactif</li><li><code class="highlighter-rouge">debian:jessie</code>: C’est l’image qu’on veut récupérer et exécuter, notons que <code class="highlighter-rouge">debian</code> est le nom du repository et <code class="highlighter-rouge">jessie</code> le tag de la version à utiliser</li><li><code class="highlighter-rouge">sh</code> : La commande qu’on cherche à lancer après avoir lancer le conteneur</li></ul><p>En d’autres termes, on a demandé à docker de récupérer une image, la lancer et d’exécuter une commande qu’on lui donne (<code class="highlighter-rouge">sh</code>) ! C’est tout !</p><p>Les conteneurs sont sensés avoir une fonction unique, par exemple on pourrait utiliser un conteneur pour lancer un processus nginx, php-fpm, go etc.. Le conteneur peut lancer cette fonction et se terminer à la fin du processus ou ne jamais s’arrêter (le cas d’un serveur web, d’un worker etc.). Si vous désirez arrêter l’exécution d’un conteneur qui tourne en rond, qui est un worker ou autre vous pouvez utiliser la commande <code class="highlighter-rouge">docker kill &lt;hash&gt;</code> ou <code class="highlighter-rouge">docker kill &lt;nom-conteneur&gt;</code>.</p><p>Reprenons la même image <code class="highlighter-rouge">debian:jessie</code> mais cette fois-ci nous lui demanderons de lancer le conteneur puis d’exécuter la commande <code class="highlighter-rouge">cat /etc/debian_version</code> sans être en mode interactif.</p><ul><li>Taper <code class="highlighter-rouge">docker run debian:jessie cat /etc/debian_version</code></li><li>La commande renvoie directement <code class="highlighter-rouge">8.11</code></li></ul><p><strong>Conclusion:</strong> ` Docker run` va récupérer une image docker puis l’exécuter, on peut exécuter l’image en mode interactif pour interagir dans le conteneur ou tout simplement lancer l’exécution d’une commande/fonction afin d’avoir la réponse directement.</p><h3 id="️-exec">➡️ Exec</h3><p><code class="highlighter-rouge">run</code> nous permettant de récupérer et lancer une image, comment fait-on quand on a un conteneur déjà lancé et qu’on veut exécuter une commande à l’intérieur de celui ci sans forcément passer à chaque fois par le shell ? c’est là qu’<code class="highlighter-rouge">exec</code> intervient. Lançons <code class="highlighter-rouge">docker run nginx</code> dans une fenêtre, puis dans une autre :</p><ul><li><code class="highlighter-rouge">docker ps</code> pour afficher la liste des conteneurs en cours d’exécution</li><li>On aperçoit bien notre conteneur<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fdf20b921646  nginx "nginx -g 'daemon of…"   6 seconds ago   Up 4 seconds    80/tcp   happy_jepsen
</code></pre></div></div></li><li>Essayons de récupérer la version de debian en tapant <code class="highlighter-rouge">docker exec happy_jepsen cat /etc/debian_version</code> (<code class="highlighter-rouge">happy_jepsen</code> doit être remplacé par le nom de votre conteneur ou son hash, ici <code class="highlighter-rouge">fdf20b921646</code>)</li><li>Le conteneur répond <code class="highlighter-rouge">9.9</code>, ce qui correspond bien à la version <code class="highlighter-rouge">stretch-slim</code> disponible dans le <a href="https://github.com/nginxinc/docker-nginx/blob/b749353968a57ebd9da17e12d23f1a5fb62f9de9/mainline/stretch/Dockerfile">Dockerfile</a> de nginx</li></ul><p><strong>Conclusion:</strong> Il faut faire attention à bien utiliser <code class="highlighter-rouge">docker run</code> et <code class="highlighter-rouge">docker exec</code>, on confond souvent les deux au début. <code class="highlighter-rouge">run</code> =&gt; Je récupère et je lance l’image (avec ou sans commande à exécuter) <code class="highlighter-rouge">exec</code> =&gt; Je lance une commande dans un conteneur <strong>déjà</strong> lancé.</p><h3 id="-votre-premier-conteneur-docker">🐥 Votre premier conteneur Docker</h3><p>Nous avons connaissance de quatre commandes docker : <code class="highlighter-rouge">run</code>, <code class="highlighter-rouge">exec</code>, <code class="highlighter-rouge">pull</code> et <code class="highlighter-rouge">ps</code>. Jusqu’à présent nous avons récupéré des images docker déjà crée, mais qu’en est-il d’une image qu’on souhaiterait créer ?</p><p>Commençons par faire notre premier fichier <strong>Dockerfile</strong>:</p><ul><li>Créer un fichier nommé <code class="highlighter-rouge">Dockerfile</code> et y ajouter :</li></ul><div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> debian:jessie</span>

<span class="k">RUN </span><span class="nb">echo</span> <span class="s2">"toto"</span>
</code></pre></div></div><p>On y voit deux instructions :</p><ul><li><code class="highlighter-rouge">FROM</code> : Demande à Docker de récupérer une image (en l’occurence <code class="highlighter-rouge">debian:jessie</code>)</li><li><code class="highlighter-rouge">RUN</code> : Exécute une commande système, ça pourrait être <code class="highlighter-rouge">ls</code>, <code class="highlighter-rouge">cp</code>, <code class="highlighter-rouge">cat</code> …</li></ul><p>Les images Docker ont besoin d’être build pour ensuite pouvoir être lancée. Pour lancer le build d’une image, il suffit d’utiliser la commande <code class="highlighter-rouge">docker build .</code>. On dit juste à Docker de build l’image courante, docker se chargera de prendre le fichier <code class="highlighter-rouge">Dockerfile</code> dans votre répertoire courant. Vous pouvez aussi spécifier un chemin vers un Dockerfile en utilisant <code class="highlighter-rouge">docker build -f repertoire/Dockerfile .</code></p><p>Voici le retour de la commande:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> btor@dev<span class="nv">$ </span> docker build <span class="nt">-f</span> <span class="nb">test</span>/Dockerfile <span class="nb">.</span>
Sending build context to Docker daemon  3.928MB
Step 1/2 : FROM debian:jessie
 <span class="nt">---</span><span class="o">&gt;</span> 7cd9fb1ee74f
Step 2/2 : RUN <span class="nb">echo</span> <span class="s2">"toto"</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 8831306e5a73
Successfully built 8831306e5a73
</code></pre></div></div><p>Trois choses importantes sont à noter :</p><ul><li>On voit très clairement les deux étapes que docker exécute : FROM et RUN</li><li>Chaque étape à son propre hash <code class="highlighter-rouge">7cd9fb1ee74f</code> pour le FROM et <code class="highlighter-rouge">8831306e5a73</code> pour le RUN, chaque étape/instruction va créer un nouveau layer (une couche).</li><li>Le build résulte d’un message <code class="highlighter-rouge">Successfully build 8831306e5a73</code></li></ul><h2 id="-les-coucheslayers">📚 Les couches/layers</h2><p>Pour chaque étape ou instruction que l’ont écris dans notre Dockerfile, Docker va créer un layer avec un <code class="highlighter-rouge">hash</code> propre à celui ci. Chaque layer est utilisable tel quel ! Oui oui ! Vous pouvez lancer un conteneur en vous basant sur le <code class="highlighter-rouge">hash</code> de votre layer (vous pouvez tester en tapant<code class="highlighter-rouge">docker run 8831306e5a73 cat /etc/debian_version</code>)</p><p><img src="https://media.giphy.com/media/2YntTHAxuJLZcKpOy9/giphy.gif" alt="" /></p><p>Vulgarisons la chose, voilà ce que vous demandez à Docker:</p><ul><li><strong>Vous:</strong> Créer moi une image qui hérite de <code class="highlighter-rouge">debian:jessie</code></li><li><strong>Docker:</strong> C’est fait, l’image est écrite dans le cache avec le hash <code class="highlighter-rouge">7cd9fb1ee74f</code></li><li><strong>Vous:</strong> En utilisant cette image, lance la commande <code class="highlighter-rouge">echo "toto"</code></li><li><strong>Docker:</strong> C’est fait, j’ai réutiliser l’image <code class="highlighter-rouge">debian:jessie</code> puis y ai lancé la commande <code class="highlighter-rouge">echo "toto"</code> et j’ai sauvegardé le résultat dans une nouvelle image avec le hash <code class="highlighter-rouge">8831306e5a73</code></li></ul><p>Pour chaque étape, docker créer une couche, c’est génial parce que ça nous permet à la fois de tester ces étapes une à une mais c’est aussi une bonne chose puisque Docker va être capable de comprendre vos modifications sur le Dockerfile et de ne relancer que ce qui a été modifié, exemple :</p><p>Vous avez un dockerfile avec différentes étapes:</p><ul><li>Etape 1 / hash 111</li><li>Etape 2 / hash 222</li><li>Etape 3 / hash 333</li></ul><p>Vous lancez votre <code class="highlighter-rouge">docker build .</code> et vous vous rendez compte que votre étape 2 n’est pas bonne. Vous l’éditez et relancé le build… et la <strong>PAF !</strong> vous vous rendez compte que Docker ne relance pas l’étape 1 mais passe directement à l’étape 2 et 3, pourquoi ? parce qu’il a déjà en mémoire l’étape 1 et sait qu’elle n’a pas été touché donc il peut repartir de là et exécuter les étapes filles. A noter que les étapes sont séquentielles, elles dépendent toutes de leur “mère”, Etape 3 dépend de Etape 2 qui elle même dépend d’Etape 1. Docker ne peut donc pas relancer uniquement L’étape 2, elle est la mère de l’étape 3 et donc Docker n’a aucun moyen de savoir si elle a été modifié ou pas.</p><h2 id="-les-instructions">📝 Les instructions</h2><p>On l’a vu plus haut, un Dockerfile est composé d’instructions, dans les instructions courantes, on retrouve:</p><ul><li><code class="highlighter-rouge">FROM</code>: C’est notre héritage de base de l’image</li><li><code class="highlighter-rouge">RUN</code>: On lance une commande dans le filesystem du conteneur</li><li><code class="highlighter-rouge">COPY</code>: Permet de copier des fichiers depuis la machine hôte vers le conteneur</li><li><code class="highlighter-rouge">LABEL</code>: Notion “d’étiquettes” qu’on donne au conteneur, utile pour mettre qui est l’auteur, le mainteneur, ou un mail de contact</li><li><code class="highlighter-rouge">ENV</code>: Affectation de variables d’environnements</li><li><code class="highlighter-rouge">EXPOSE</code>: Permet d’exposer des ports, par exemple dans le cas d’un conteneur de serveur web, on exposera le port 80 et 443 afin de pouvoir accéder au processus Nginx/Apache</li><li><code class="highlighter-rouge">WORKDIR</code>: Change le répertoire de travail</li><li><code class="highlighter-rouge">ENTRYPOINT</code>: Lance un script d’initialisation du conteneur</li><li><code class="highlighter-rouge">CMD</code>: Une fois le conteneur lancé, CMD sera utilisé comme commande par défaut pour lancer le conteneur (typiquement sur un conteneur <code class="highlighter-rouge">node</code> on pourrait avoir un <code class="highlighter-rouge">node start</code>)</li></ul><p>Ces instructions peuvent être utilisées dans l’ordre que vous voulez, à l’exception de certaines… (bah oui, il y a toujours un truc bizarre qui se cache…). Dans vos premiers Dockerfile vous utiliserez <strong>toujours</strong> l’instruction <code class="highlighter-rouge">FROM</code> en première. Tout simplement parce que votre image commence toujours à partir d’une autre image, vous avez la possibilité de créer votre propre image de “départ”. C’est ce qu’on appelle les <code class="highlighter-rouge">base image</code>. Il n’est pas du tout nécessaire de savoir créer des <code class="highlighter-rouge">base image</code> pour utiliser Docker mais pour les intéressés <a href="https://docs.docker.com/develop/develop-images/baseimages/">voici le lien</a>.</p><p>Mention spéciale aussi pour <code class="highlighter-rouge">CMD</code> et <code class="highlighter-rouge">ENTRYPOINT</code> qui sont souvent utilisées à la fin du Dockerfile pour des soucis de lisibilité/compréhension et parce qu’elles définissent le script/command à lancé une fois le conteneur “prêt”.</p><h2 id="️-push-it-to-the-limit">🕊️ Push it to the limit</h2><p><img src="https://media.giphy.com/media/owiooI9tn2hjy/giphy.gif" alt="" /></p><p>On a arrive à construire nos images en locale, à les lancer, lancer des commandes à l’intérieur de nos conteneurs etc.. cool ! mais comment fait-on pour les sauvegarder sur le hub ?</p><p>Première étape, votre <code class="highlighter-rouge">Dockerfile</code> doit être versionné avec github (ou autre) afin de garder une trace de votre image. La deuxième étape est toute simple, pour chaque version de votre image, vous allez lui appliquer un <code class="highlighter-rouge">tag</code> et l’envoyer sur le hub docker.</p><p>Faisons un essai avec ce Dockerfile:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM debian:jessie
LABEL <span class="nv">maintainer</span><span class="o">=</span><span class="s2">"Thibaut BAYER&lt;bt0r&gt;"</span>
RUN <span class="nb">echo</span> <span class="s2">"Bienvenue sur votre première image docker"</span>
COPY ./script.sh /root/script.sh
RUN <span class="nb">chmod </span>777 /root/script.sh
ENTRYPOINT <span class="o">[</span><span class="s2">"/root/script.sh"</span><span class="o">]</span>
</code></pre></div></div><p>Au même endroit que le Dockerfile, créez un fichier nommé <code class="highlighter-rouge">script.sh</code> avec ceci à l’intérieur</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"WOW ca marche"</span>
</code></pre></div></div><p>Lancons le build de l’image :</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build .
</code></pre></div></div><p>Ce qui nous donne</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sending build context to Docker daemon  3.072kB
Step 1/6 : FROM debian:jessie
 <span class="nt">---</span><span class="o">&gt;</span> d69ffb5f6cbf
Step 2/6 : LABEL <span class="nv">maintainer</span><span class="o">=</span><span class="s2">"Thibaut BAYER&lt;bt0r&gt;"</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 2ffcffa9a5a8
Step 3/6 : RUN <span class="nb">echo</span> <span class="s2">"Bienvenue sur votre première image docker"</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> cb64dcad7887
Step 4/6 : COPY ./script.sh /root/script.sh
 <span class="nt">---</span><span class="o">&gt;</span> 70d8badd9532
Step 5/6 : RUN <span class="nb">chmod </span>777 /root/script.sh
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>a7f7f63d4490
Removing intermediate container a7f7f63d4490
 <span class="nt">---</span><span class="o">&gt;</span> 8df44389144c
Step 6/6 : ENTRYPOINT <span class="o">[</span><span class="s2">"/root/script.sh"</span><span class="o">]</span>
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>0d4194fc0f3e
Removing intermediate container 0d4194fc0f3e
 <span class="nt">---</span><span class="o">&gt;</span> 1faa94d56d33
Successfully built 1faa94d56d33

</code></pre></div></div><p>Vous noterez qu’une seule étape de mon Dockerfile crée quelque chose dans le conteneur, c’est l’étape “COPY” qui copie un fichier depuis le système hôte jusqu’au conteneur. L’instructions <code class="highlighter-rouge">RUN echo "Bienvenue ..."</code> ne s’affiche que lors de l’exécution du build, pas une fois l’image crée/lancée.</p><p>Notre image est crée en local, on peut l’exécuter en faisant <code class="highlighter-rouge">docker run 1faa94d56d33</code> (où <code class="highlighter-rouge">1faa94d56d33</code> correspond au dernier layer construit).</p><p><code class="highlighter-rouge">WOW ca marche</code> s’affiche, génial, sauf que voilà, notre image n’a pas de version/nom du coup c’est un peu chiant d’utiliser à chaque fois le hash de celle-ci.</p><p>Et si on la tagguait ? Pour tagguer, il suffit d’utiliser l’option <code class="highlighter-rouge">-t</code> :</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nb">.</span> <span class="nt">-t</span> btor/wow

Sending build context to Docker daemon  3.072kB
Step 1/6 : FROM debian:jessie
 <span class="nt">---</span><span class="o">&gt;</span> d69ffb5f6cbf
Step 2/6 : LABEL <span class="nv">maintainer</span><span class="o">=</span><span class="s2">"Thibaut BAYER&lt;bt0r&gt;"</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 2ffcffa9a5a8
Step 3/6 : RUN <span class="nb">echo</span> <span class="s2">"Bienvenue sur votre première image docker"</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> cb64dcad7887
Step 4/6 : COPY ./script.sh /root/script.sh
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 70d8badd9532
Step 5/6 : RUN <span class="nb">chmod </span>777 /root/script.sh
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 8df44389144c
Step 6/6 : ENTRYPOINT <span class="o">[</span><span class="s2">"/root/script.sh"</span><span class="o">]</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 1faa94d56d33
Successfully built 1faa94d56d33
Successfully tagged btor/wow:latest
</code></pre></div></div><p>On note ici que j’ai utilisé : <code class="highlighter-rouge">btor</code> comme nom de compte docker hub, <code class="highlighter-rouge">wow</code> comme repository et c’est tout, docker m’a automatiquement attribué la version <code class="highlighter-rouge">latest</code>, ce qui veut dire que si je refait un build de cette même image ou d’une image modifié avec le même tag, elle surchargera ma précédente. Et oui jamy !</p><p><img src="https://media1.tenor.com/images/43d1951bb99d9223dbdc3146ef8b4f60/tenor.gif?itemid=11967093" alt="" /></p><p>Pour spécifier une version, on peut tout simplement ajouter <code class="highlighter-rouge">:v1</code> par exemple, ce qui donnerait</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nb">.</span> <span class="nt">-t</span> &lt;vous&gt;/wow:v1
</code></pre></div></div><p>La version peut s’appeller de n’importe quelle facon <code class="highlighter-rouge">10.1</code>, <code class="highlighter-rouge">v1</code>, <code class="highlighter-rouge">v1-alpha</code> …</p><p>Notre image en v1 crée en local, il serait temps de l’envoyer sur le docker hub en tapant <code class="highlighter-rouge">docker push &lt;vous&gt;/wow:v1</code> (pensez à remplacer <code class="highlighter-rouge">&lt;vous&gt;</code> par votre nom de compte docker hub que ce soit pour vos builds ou vos push sinon vous n’aurez pas les droits d’envoyer sur un repository dont vous n’êtes pas le propriétaire)</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker push &lt;vous&gt;/wow:v1
The push refers to repository <span class="o">[</span>docker.io/&lt;vous&gt;/wow]
abd25ccbce1b: Pushed 
c70e7bc63ac2: Pushed 
790002cce4fd: Mounted from library/debian 
v1: digest: sha256:90717eefe2dedddfd65d818f88f1c75aa29b7f5c3aafc43dba2b0fca8656cf9b size: 943
</code></pre></div></div><p>Notre image est désormais disponible sur le docker hub, elle est réutilisable par n’importe qui (repository public) ! Top ! Maintenant éditons notre <code class="highlighter-rouge">script.sh</code> et remplaçons le <code class="highlighter-rouge">WOW ca marche</code> par <code class="highlighter-rouge">WOW c'est la v2 !</code> et taggons tout ca en v2</p><ul><li><code class="highlighter-rouge">vim script.sh</code> -&gt; Wow c’est la v2 !</li><li><code class="highlighter-rouge"> docker build . -t &lt;vous&gt;/wow:v2</code></li><li><code class="highlighter-rouge">docker push &lt;vous&gt;/wow:v2</code></li></ul><p>Une fois le push effectué, rendez vous sur votre compte docker hub. Vous devriez avoir 2 versions (<code class="highlighter-rouge">v1</code> et <code class="highlighter-rouge">v2</code>) dans votre repository <code class="highlighter-rouge">wow</code>.</p><p>Les deux versions peuvent être récupérées par n’importe qui en faisant <code class="highlighter-rouge">docker pull &lt;vous&gt;/wow:v1</code> ou <code class="highlighter-rouge">docker run &lt;vous&gt;/wow:v2</code>, si l’image n’existe pas en local, docker va rechercher sur docker hub et va automatiquement télécharger l’image.</p><p>Et si on testait ce fonctionnement en local ? :D</p><ul><li>Listez vos images locales en tapant <code class="highlighter-rouge">docker images &lt;vous&gt;/wow</code></li><li>Supprimez vos 2 versions locale <code class="highlighter-rouge">v1</code> et <code class="highlighter-rouge">v2</code> en faisant ` docker rmi –force 1faa94d56d33 1faa94d56d33` (avec vos hash d’images)</li></ul><p><strong>docker images</strong> permet de lister les images disponibles en local, tandis que <strong>docker rmi</strong> supprime les images (<code class="highlighter-rouge">rmi</code> pour remove images).</p><p>Les images étant supprimées, testons de récupérer les images que vous avez publiez :</p><ul><li><code class="highlighter-rouge">docker run &lt;vous&gt;/wow:v1</code> =&gt; WOW ca marche</li><li><code class="highlighter-rouge">docker run &lt;vous&gt;/wow:v2</code> =&gt; WOW c’est la v2 !</li></ul><p>Dans les deux cas, docker nous informe bien que l’image n’est pas disponible en local <code class="highlighter-rouge">Unable to find image '&lt;vous&gt;/wow:v1' locally</code>. Vous pouvez d’ailleurs essayer avec les images que j’ai moi même posté sur le hub sans remplacer par votre nom d’utilisateur : <code class="highlighter-rouge">docker run btor/wow:v1</code> vous devriez avoir le même résultat mais docker retéléchargera l’image (vu que pour lui elle est différente de la votre).</p><h1 id="conclusion">Conclusion</h1><p>Vous avez désormais les notions de bases de docker, vous savez comment docker fonctionne, comment récupérer/stoper/lancer/créer/pousser une image. Si vous avez aimé cet article ou que vous désirez avoir plus d’informations (voir même d’autres articles dans la même veine, <code class="highlighter-rouge">docker-compose</code>, docker avancé, <code class="highlighter-rouge">kubernetes</code> etc..) faites le moi savoir :D</p></div><ul class="post__social"><li><a href="https://www.facebook.com/sharer/sharer.php?u=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-facebook"></i></a></li><li><a href="https://twitter.com/intent/tweet?&text=Docker, les bases+https://btor.fr/2019/07/03/docker-bases-tuto/+by+Thibaut BAYER" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="https://plus.google.com/share?url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-google-plus"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?mini=true&source=Docker, les bases&summary=&url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-linkedin"></i></a></li><li><a href="https://www.stumbleupon.com/badge/?url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-stumbleupon"></i></a></li><li><a href="https://www.reddit.com/submit?url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-reddit-alien"></i></a></li><li><a href="https://www.tumblr.com/share/link?url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-tumblr"></i></a></li><li><a href="https://www.pinterest.com/pin/create/link/?description=&media=https://btor.fr/assets/images/docker-bases/main.png&url=https://btor.fr/2019/07/03/docker-bases-tuto/" target="_blank"><i class="fa fa-pinterest"></i></a></li></ul></div></div><div class="section-padding--none"><div class="grid"><hr class="sep"/></div></div><div class="section-padding"><div class="grid-small"> <span class="post__author">Posté par <a href="http://btor.fr" title="More By Thibaut BAYER">Thibaut BAYER</a></span><p class="post__bio">Passionné d'informatique, de développement web & applicatif depuis plus de 10 ans. Je partage mon quotidien de tech !</p></div></div></article></div><section class="related section-padding"><div class="grid-xlarge"><h2 class="related__title"></h2><div class="related__container"><article class="related__post"> <a class="related__link" href="https://btor.fr/2019/07/03/docker-bases-tuto/"><figure class="related__img"> <img src="/assets/images/docker-bases/main.png" alt="Docker, les bases"/></figure><div><h2 class="related__text">Docker, les bases</h2></div></a></article></div></div></section></main><footer class="footer section-padding"><div class="grid"><div class="subscribe" id="subscribe"><div class="subscribe__container"> <span class="subscribe__title">Restons en contact</span><ul class="footer__social"><li><a href="https://twitter.com/biiitor" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="https://www.instagram.com/btor.fr/" target="_blank"><i class="fa fa-instagram"></i></a></li><li><a href="https://www.linkedin.com/in/thibaut-bayer//" target="_blank"><i class="fa fa-linkedin"></i></a></li><li><a href="https://github.com/bt0r" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="https://twitch.tv/bt0r" target="_blank"><i class="fa fa-twitch"></i></a></li></ul></div></div><hr class="sep--white"/><div class="footer__container"><p>Catégories</p><ul class="footer__tags"><li><a class="footer__link" href="/tag/materiel">Materiel</a></li><li><a class="footer__link" href="/tag/test">Test</a></li><li><a class="footer__link" href="/tag/tutorial">Tutorial</a></li><li><a class="footer__link" href="/tag/photos--vido">Photos & Vidéo</a></li><li><a class="footer__link" href="/tag/bon-plans">Bon Plans</a></li></ul></div></div></footer><section class="contact popup"><div class="popup__close"><div class="popup__exit"></div></div><div class="contact__container popup__container"><div class="contact__img"><figure class="absolute-bg" style="background-image: url(/assets/images/logo/logo.dark.small.png);"></figure></div><div class="contact__content"><div class="contact__mast section-padding--half"><div class="grid"><h2>Contact</h2></div></div><div class="section-padding--none"><hr class="sep"/></div><div class="contact__form section-padding--half"><div class="grid-xlarge"> <form id="form" class="form" action="https://formcarry.com/s/HkIo0nMb7" method="POST"><div class="form__subcontainer"><div> <label for="form-first-name">First Name</label> <input type="text" name="first-name" id="form-first-name" required></div><div> <label for="form-last-name">Last Name</label> <input type="text" name="last-name" id="form-last-name" required></div></div><div> <label for="form-email">E-Mail</label> <input type="email" name="email" id="form-email" required></div><div> <label for="form-message">Message</label> <textarea name="message" id="form-message" rows="3"></textarea></div><div class="form__submit"><div class="form__btn"> <input type="submit" value="Send"></div></div><p class="form__message"></p></form></div></div></div></div></section><script src="/assets/js/app.min.js"></script></body></html>
  